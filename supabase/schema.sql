-- DailyHush Supabase schema (DDL + RLS + RPC)

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  avatar_url text,
  role text not null default 'viewer',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.authors (
  id uuid primary key default gen_random_uuid(),
  profile_id uuid references public.profiles(id),
  name text not null,
  bio text,
  avatar_url text,
  socials jsonb default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.categories (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,
  name text not null,
  description text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.tags (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,
  name text not null
);

create table if not exists public.posts (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,
  title text not null,
  excerpt text,
  content_md text,
  content_html text,
  cover_image text,
  status text not null default 'draft',
  scheduled_at timestamptz,
  published_at timestamptz,
  author_id uuid references public.authors(id) on delete set null,
  seo_title text,
  seo_description text,
  og_image text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.post_categories (
  post_id uuid references public.posts(id) on delete cascade,
  category_id uuid references public.categories(id) on delete cascade,
  primary key (post_id, category_id)
);

create table if not exists public.post_tags (
  post_id uuid references public.posts(id) on delete cascade,
  tag_id uuid references public.tags(id) on delete cascade,
  primary key (post_id, tag_id)
);

create table if not exists public.post_revisions (
  id bigint generated by default as identity primary key,
  post_id uuid references public.posts(id) on delete cascade,
  snapshot jsonb not null,
  created_at timestamptz not null default now(),
  created_by uuid references public.profiles(id)
);

create table if not exists public.site_settings (
  id bool primary key default true,
  site_title text,
  site_tagline text,
  logo_url text,
  favicon_url text,
  default_og_image text,
  newsletter_embed_html text,
  updated_at timestamptz not null default now()
);

-- Indexes
create index if not exists posts_status_idx on public.posts(status);
create index if not exists posts_published_idx on public.posts(published_at desc);
create index if not exists posts_title_trgm on public.posts using gin (title gin_trgm_ops);
create index if not exists posts_content_trgm on public.posts using gin (content_md gin_trgm_ops);

-- Helpers
create or replace function public.slugify(txt text) returns text language sql immutable as $$
  select lower(regexp_replace(trim(coalesce(txt,'')), '[^a-zA-Z0-9]+', '-', 'g'))
$$;

-- Triggers
create or replace function public.posts_biu() returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  if new.slug is null or new.slug = '' then
    new.slug := public.slugify(new.title);
  else
    new.slug := public.slugify(new.slug);
  end if;
  if new.status = 'scheduled' and new.scheduled_at <= now() then
    new.status := 'published';
    new.published_at := now();
  end if;
  return new;
end $$;

drop trigger if exists tg_posts_biu on public.posts;
create trigger tg_posts_biu before insert or update on public.posts for each row execute function public.posts_biu();

create or replace function public.touch_updated_at() returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

drop trigger if exists tg_profiles_touch on public.profiles;
create trigger tg_profiles_touch before update on public.profiles for each row execute function public.touch_updated_at();
drop trigger if exists tg_authors_touch on public.authors;
create trigger tg_authors_touch before update on public.authors for each row execute function public.touch_updated_at();
drop trigger if exists tg_categories_touch on public.categories;
create trigger tg_categories_touch before update on public.categories for each row execute function public.touch_updated_at();
drop trigger if exists tg_settings_touch on public.site_settings;
create trigger tg_settings_touch before update on public.site_settings for each row execute function public.touch_updated_at();

-- RPC for list_posts
create or replace function public.list_posts(
  q text default null,
  category_slug text default null,
  page int default 1,
  page_size int default 12
) returns table (
  id uuid, slug text, title text, excerpt text, cover_image text,
  published_at timestamptz, author_name text
) language sql stable as $$
  with base as (
    select p.*, a.name as author_name
    from public.posts p
    left join public.authors a on a.id = p.author_id
    where p.status = 'published'
  ),
  filtered as (
    select *
    from base
    where (q is null or (title ilike '%'||q||'%' or content_md ilike '%'||q||'%'))
      and (category_slug is null or exists (
        select 1 from public.post_categories pc
        join public.categories c on c.id = pc.category_id
        where pc.post_id = base.id and c.slug = category_slug
      ))
  )
  select id, slug, title, excerpt, cover_image, published_at, author_name
  from filtered
  order by published_at desc nulls last
  limit page_size offset greatest((page-1),0)*page_size;
$$;

-- RLS enable
alter table public.profiles enable row level security;
alter table public.authors enable row level security;
alter table public.categories enable row level security;
alter table public.tags enable row level security;
alter table public.posts enable row level security;
alter table public.post_categories enable row level security;
alter table public.post_tags enable row level security;
alter table public.post_revisions enable row level security;
alter table public.site_settings enable row level security;

-- Role helpers
create or replace function public.is_admin() returns boolean language sql stable as
  $$ select exists (select 1 from public.profiles where id = auth.uid() and role = 'admin'); $$;
create or replace function public.is_editor() returns boolean language sql stable as
  $$ select exists (select 1 from public.profiles where id = auth.uid() and role in ('admin','editor')); $$;

-- Policies
create policy if not exists "profiles self read" on public.profiles for select using (auth.uid() = id);
create policy if not exists "profiles upsert self" on public.profiles for insert with check (auth.uid() = id);
create policy if not exists "profiles update self" on public.profiles for update using (auth.uid() = id) with check (auth.uid() = id);

create policy if not exists "posts public read published" on public.posts for select using (status = 'published');
create policy if not exists "posts editors read" on public.posts for select using (public.is_editor());
create policy if not exists "posts editors write" on public.posts for insert with check (public.is_editor());
create policy if not exists "posts editors update" on public.posts for update using (public.is_editor()) with check (public.is_editor());
create policy if not exists "posts editors delete" on public.posts for delete using (public.is_admin());

create policy if not exists "categories public read" on public.categories for select using (true);
create policy if not exists "categories editors write" on public.categories for insert with check (public.is_editor());
create policy if not exists "categories editors update" on public.categories for update using (public.is_editor()) with check (public.is_editor());
create policy if not exists "categories admins delete" on public.categories for delete using (public.is_admin());

create policy if not exists "tags public read" on public.tags for select using (true);
create policy if not exists "tags editors write" on public.tags for insert with check (public.is_editor());
create policy if not exists "tags editors update" on public.tags for update using (public.is_editor()) with check (public.is_editor());
create policy if not exists "tags admins delete" on public.tags for delete using (public.is_admin());

create policy if not exists "post_categories editors write" on public.post_categories for all using (public.is_editor()) with check (public.is_editor());
create policy if not exists "post_tags editors write" on public.post_tags for all using (public.is_editor()) with check (public.is_editor());

create policy if not exists "settings public read" on public.site_settings for select using (true);
create policy if not exists "settings editors update" on public.site_settings for all using (public.is_editor()) with check (public.is_editor());

-- Auth trigger to create profile
create or replace function public.handle_new_user() returns trigger language plpgsql as $$
begin
  insert into public.profiles (id, display_name, role)
  values (new.id, coalesce(new.raw_user_meta_data->>'name', 'User'), 'viewer');
  return new;
end $$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created after insert on auth.users for each row execute function public.handle_new_user();

-- Storage notes: create public bucket `images` with read public; write guarded via is_editor() JWT rule in storage policies.

-- Seed
insert into public.categories (slug,name)
values ('wellness','Wellness'),('beauty','Beauty'),('tech','Tech')
on conflict (slug) do nothing;

insert into public.tags (slug,name)
values ('ai','AI'),('skincare','Skincare'),('wearables','Wearables')
on conflict (slug) do nothing;

insert into public.authors (name, bio, avatar_url)
values ('DailyHush Team','Editorial team behind DailyHush','')
on conflict do nothing;

insert into public.posts (title, excerpt, content_md, status, author_id)
select 'AI for Skincare: What Works Today', 'A practical look at AI-powered skincare tools.', '# Intro\nContent...', 'draft', id
from public.authors limit 1;

